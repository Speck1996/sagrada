package com.model.cards.concretetoolcards;

import com.model.MoveAbortedException;
import com.model.PlayerInGame;
import com.model.WrongInputSyntaxException;
import com.model.gameboard.RoundBoard;
import com.model.dice.*;
import com.model.patterns.DiceNotPickableException;
import com.model.patterns.DieNotPlaceableException;

import java.util.ArrayList;
import java.util.List;

import static com.model.patterns.WindowPatternCard.COL;
import static com.model.patterns.WindowPatternCard.ROW;


/**Class that contains several method for user input  parsing, it also helps the toolcards during their execution storing
 * for example the die picked or saving the coordinates of moved dice . Attribute oldDiceCoordinates is a list of arrays of
 * integer that contain the coordinates of picked die from the window (useful to check if the player tries to move the dice in the same place where it was taken)
 * alreadyUsedCoordinates instead check if the player tries to move the same dice twice (it saves the coordinate where dice
 * are moved to). Dice selectedDie is the die selected from the stock that will be manipulated by the toolcard.
 * The PlayerInGame toolCardUser is used to notify the player the changes of the model.
 * The private static final string wrongSyntaxInput is a standard format to communicate errors regarding wrong syntax
 *
 */

public class ToolCardInputHandler {
    private List<Integer[]> oldDiceCoordinates;
    private List<Integer[]> alreadyUsedCoordinates;
    private Dice selectedDie;
    private PlayerInGame toolCardUser;

    private static final String wrongSyntaxInput = " not accepted, wrong syntax input";



    public ToolCardInputHandler(){
        this.alreadyUsedCoordinates= new ArrayList<>();
        this.oldDiceCoordinates= new ArrayList<>();
    }


    /** set the toolCardUser attribute, called in toolcard payCard method, after the user pays the card
     * @param player will be set as the toolCardUser, used to notify the user of model changes or errors
     */
    public void setPlayer(PlayerInGame player){
        this.toolCardUser = player;
    }

    /**Parses the given string and generate an array of Integer where the coordinates parsed from the string will be put
     * Before doing that a check is made on the string too see if it is an "a" : this is the command to abort toolcard execution
     * and if it conforms the predefined coordinate syntax input row,column. After the parsing this method checks that the
     * parsed coordinates are suitable for the window matrix. If the check doens't throw the exception the array is returned
     * @param userInput string to be parsed, represents the user input
     * @return coordinates, the array of integer where the user chosen coordinates are stored
     * @throws WrongInputSyntaxException, if the user violates the predefined input format, or write something not parsable
     * @throws MoveAbortedException, if the user writes an a, meaning that he wants to abort the toolcard execution
     */
    public  Integer[] getCoordinates(String userInput) throws WrongInputSyntaxException,MoveAbortedException {
        Integer[] coordinates = new Integer[2];
        if(userInput.equals("a")){
            throw new MoveAbortedException("Space coordinate selection aborted");
        }

        if(userInput.length()!=3 || userInput.charAt(1) != ','){
            throw new WrongInputSyntaxException(userInput + wrongSyntaxInput);
        }
        try {
            coordinates[0] = Integer.parseInt(userInput.substring(0,1)) - 1;
            coordinates[1] = Integer.parseInt(userInput.substring(2)) - 1;
        }catch(Exception error) {
            error.printStackTrace();
            throw  new WrongInputSyntaxException(userInput+  wrongSyntaxInput);
        }


        if(!((coordinates[0] >= 0 && coordinates[0] < ROW )&& (coordinates[1] >= 0 && coordinates[1] < COL))){
            throw new WrongInputSyntaxException(userInput+ " not accepted: "+ "selected space doesn't exist");
        }

        return coordinates;
    }


    /**Parses the given string using the getCoordinates method of this class. If the coordinates correspond to one of the
     * alreadyUsedCoordinates an exception is thrown. If not the coordinates are used to get a copy of the dice of the
     * selected space and storing it in the selectedDie attribute. If the die doesn't match the colorConstraint or/and the
     * shade Constraint an exception is generated by the selectSpaceWithDie method and thrown.
     * If the exception is not thrown  the coordinates parsed form the userInput
     * string are added to the oldDiceCoordinates. In the end the user is notified with the updated window
     * @param  userInput the string corresponding to the user input, must respect the predefined format: row,column
     * @param colorConstraint the color constraint for dice selection, if neutral the dice can be of every color
     * @param shadeConstraint the shade constraint for the dice selection, if neutral the dice can be of every shade
     * @throws WrongInputSyntaxException, if the user violates the predefined input format, or write something not parsable
     * @throws MoveAbortedException, if the user writes an a, meaning that he wants to abort the toolcard execution
     * @throws DieAlreadyMovedException if the generate coordinates correspond to one contained in the already user coordinates,
     *                                  meaning that the user wanted to select a die already moved
     * @throws DiceNotPickableException, diceSpace selected with the generated coordinates contains a die that violates the colorConstraint
     *                                   or the shade constraint
     * @throws NoDiceException if the diceSpace selected with the generated coordinates doesn't contain any die
     */

    public void pickWindowDie(String userInput, DiceColor colorConstraint, DiceShade shadeConstraint) throws DieAlreadyMovedException,MoveAbortedException,DiceNotPickableException,WrongInputSyntaxException,NoDiceException{


        Integer[] coordinates = getCoordinates(userInput);

        for(int i = 0; i < this.alreadyUsedCoordinates.size();i++){
            if(this.alreadyUsedCoordinates.get(i)[0].equals(coordinates[0] )&& this.alreadyUsedCoordinates.get(i)[1].equals(coordinates[1])){
                throw new DieAlreadyMovedException("Selected die already moved");
            }
        }

        selectedDie = new Dice(this.toolCardUser.getWindow().getDiceFromSpace(coordinates,colorConstraint,shadeConstraint));

        oldDiceCoordinates.add(coordinates.clone());

        this.toolCardUser.notifyViewObserver(this.toolCardUser.getWindow().toString());
    }


    /**Method that parses the given string with the generateCoordinate, and generated the coordinates array it checks if there is
     *a array of integer corresponding to the one generated in the oldDiceCoordinates, throwing an exception in that case
     * (the user can't move the die back where it was). The generated coordinates are used to place the die contained in the
     * selectedDie attribute in the desired space respecting the given constraint (if colorRestriction is true then
     * the placement must respect that constraint,same for shadeRestriction). After the dice is set,the boolean parameter of
     * toolCardUser dicePlaced is set true and the user is notified with the updated window
     * @param userInput string representing the user input
     * @param colorRestriction the boolean used in the placeDice to check or not check the color constraint
     * @param shadeRestriction the boolean used in the shadeRestriction to check or not check the shade constraint
     * @throws DieNotPlaceableException if the die can't be placed in the desired space
     * @throws WrongInputSyntaxException if the user input doesn't respect the predefined syntax
     * @throws MoveAbortedException if the user input corresponds to "a"
     * @see com.model.patterns.WindowPatternCard
     */
    public void placePickedDie(String userInput, boolean colorRestriction, boolean shadeRestriction)throws DieNotPlaceableException,WrongInputSyntaxException,MoveAbortedException{
        Integer[] coordinates = getCoordinates(userInput);


        for(int i = 0; i < this.oldDiceCoordinates.size();i++){
            if(this.oldDiceCoordinates.get(i)[0].equals(coordinates[0] )&& this.oldDiceCoordinates.get(i)[1].equals(coordinates[1])){
                throw new DieNotPlaceableException("can't place the die back where it was");
            }
        }

        this.toolCardUser.getWindow().placeDice(coordinates[0], coordinates[1], selectedDie, colorRestriction, shadeRestriction);
        alreadyUsedCoordinates.add(coordinates.clone());


        //oldCoordinates flush
        oldDiceCoordinates = new ArrayList<>();


        this.toolCardUser.notifyViewObserver(this.toolCardUser.getWindow().toString());

    }


    /**Method that parses the string to generate the round coordinates. the string must respect the roundboard predefined
     * input syntax round,dieindex. The method also checks if the generate coordinate can be used in the roundboard
     * controlling if their values are included from 0 to the round and die list size.
     *In the end the array is returned
     * @param gameRoundBoard the roundboard, used to make the check for generated coordinate
     * @param userInput the user input string
     * @return roundIndexSelection, an array of integer where the coordinates are stored
     * @throws MoveAbortedException if the input corresponds to an "a"
     * @throws WrongInputSyntaxException if the input doesn't respect the predefined syntax
     */
    Integer[] selectRoundCoordinates(RoundBoard gameRoundBoard, String userInput) throws MoveAbortedException,WrongInputSyntaxException{

        Integer[] roundIndexSelection = new Integer[2]; //<-- coordinates of the die [0] is the round, [1] is the die index
        if(userInput.equals("a")){
            throw new MoveAbortedException("Roundboard round and die index selection aborted");
        }
        if(userInput.length() != 3 || userInput.charAt(1) != ','){
            throw new WrongInputSyntaxException(userInput+wrongSyntaxInput);
        }
        try {
            roundIndexSelection[0] = Integer.parseInt(userInput.substring(0, 1)) - 1;
            roundIndexSelection[1] = Integer.parseInt(userInput.substring(2)) - 1;
        }
        catch(Exception error){
            throw new WrongInputSyntaxException(userInput + wrongSyntaxInput);
        }
        if(!(roundIndexSelection[0] >= 0 && roundIndexSelection[0] < gameRoundBoard.getSize())){
            throw new WrongInputSyntaxException(userInput+ " not accepted: wrong round index");
        }
        if(!(roundIndexSelection[1] >= 0 && roundIndexSelection[1] < gameRoundBoard.getDice(roundIndexSelection[0]).size())){
            throw new WrongInputSyntaxException(userInput+ " not accepted: wrong die index");
        }
        return roundIndexSelection;
    }


    /**Method that parses the string to generate the coordinate of the desired die from the stock.
     * It checks if the string respects the predefined syntax (the input is just the string format of the desired die index,
     * example "1", means first die in the stock).
     * If the input corresponds to an "a" the toolcard execution is aborted, otherwise a check is made on the input string.
     * if the string corresponds passes the checks the selectedDie parameter is set with the selected die from the stock
     * (picked with the integer obtained by string parsing). The dice is removed from the stock and the model changes are
     * notified to the user through the player observer
     * @param stock the stock where the die will be picked from
     * @param userInput the string corresponding to user input
     * @throws MoveAbortedException if the string matches "a"
     * @throws NoDiceException if there is no die in the stock
     * @throws WrongInputSyntaxException if the string format doesn't respect the predefined syntax
     */

    public void pickStockDie(Stock stock, String userInput)throws MoveAbortedException,NoDiceException,WrongInputSyntaxException {

        int stockDieIndex;

        this.toolCardUser.notifyViewObserver("Select die index from the stock");


        if(userInput.equals("a")){
            throw new MoveAbortedException("Die from stock selection aborted");
        }

        if(userInput.length() !=1 ){
            throw new WrongInputSyntaxException(userInput+ wrongSyntaxInput);
        }




        try {
            stockDieIndex = Integer.parseInt(userInput) - 1;
        }catch(NumberFormatException error) {
            error.printStackTrace();
            this.toolCardUser.notifyViewObserver("Wrong syntax input!");
            throw  new WrongInputSyntaxException("User selected a wrong index");
        }
        try {
            //picking the die
            selectedDie = new Dice(stock.getDice(stockDieIndex));
            stock.removeDice(stockDieIndex);
            toolCardUser.notifyViewObserver("You picked the die " + selectedDie.toString()+"\n");
            toolCardUser.notifyViewObserver("Stock: "+ stock.toString()+"\n");

        }catch(NoDiceException error){
            System.out.println("Index out of bound");
            throw new NoDiceException(userInput + wrongSyntaxInput);
        }

    }

    /**used to get the already used coordinates
     * @return alreadyUsedCoordinates attribute
     */
    List<Integer[]> getAlreadyUsedCoordinates(){
        return this.alreadyUsedCoordinates;
    }


    /**used to get the selectedDie in some toolcards that neeed to manipulate the die
     * @return Dice selectedDie attribute
     */
    Dice getSelectedDie(){
        return  selectedDie;
    }

    /**set the selected die to the one given, used in toolcards that change the stock die with something else
     * @param selectedDie the die that will be se as selectedDie
     */
    void setSelectedDie(Dice selectedDie){
        this.selectedDie = selectedDie;
    }


    /**used when the toolcard reach the EXECUTED or ABORT state to reset the attributes of the toolcardHandler
     * They are used and resetted for every toolcard execution
     */
    public void flush(){
        this.selectedDie = null;
        this.oldDiceCoordinates = new ArrayList<>();
        this.alreadyUsedCoordinates = new ArrayList<>();
    }


}
